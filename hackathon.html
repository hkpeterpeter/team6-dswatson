
<!DOCTYPE html>
<!-- https://stackoverflow.com/questions/42720488/d3-v4-drag-line-chart-with-x-and-y-axes -->
<!-- Thanks to Mark - https://stackoverflow.com/users/16363/mark -->

<img id="upImg" src="price_elastic.png" style="width:700px;" />

<table id="bottomVis">
  <tr>
    <td>
  <h3>Demand Curve: Quantity(x-axis)  |  Profit(y-axis) </h3>
</td>
</tr>
  <tr>
    <td>

          <svg width="500" height="350"></svg>

    </td>
    <td>
      <h3>Current:</h3>
      <h4 style="color:red;" id="labelQCurrent">Q:</h4>
      <h4 style="color:red;" id="labelPCurrent">P:</h4>


      <h3>Optimal:</h3>
      <h4 style="color:green;" id="labelQOptimal">Q:</h4>
      <h4 style="color:green;" id="labelPOptimal">P:</h4>

      <h3>Target:</h3>
      <h4 style="color:purple;" id="labelQTarget">Q:</h4>
      <h4 style="color:purple;" id="labelPTarget">P:</h4>


    </td>
  </tr>
</table>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
<script>

$("#bottomVis").hide();
$("#upImg").on("click", function(){
  $("#bottomVis").show();
});

//d3.select("body").transition()
  //  .style("background-color", "black");

var svg = d3.select("svg"),
    margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom;


/*let points = d3.range(1, 10).map(function(i) {
    return [i * width / 10, 50 + Math.random() * (height - 100)];
});
*/



let ps = [ 51.06181607,  51.41371691,  51.76561776,  52.11751861,
        52.46941946,  52.8213203 ,  53.17322115,  53.525122  ,
        53.87702285,  54.2289237 ,  54.58082454,  54.93272539,
        55.28462624,  55.63652709,  55.98842793,  56.34032878,
        56.69222963,  57.04413048,  57.39603133,  57.74793217,
        58.09983302,  58.45173387,  58.80363472,  59.15553557,
        59.50743641,  59.85933726,  60.21123811,  60.56313896,
        60.9150398 ,  61.26694065,  61.6188415 ,  61.97074235,
        62.3226432 ,  62.67454404,  63.02644489,  63.37834574,
        63.73024659,  64.08214743,  64.43404828,  64.78594913,
        65.13784998,  65.48975083,  65.84165167,  66.19355252,
        66.54545337,  66.89735422,  67.24925507,  67.60115591,
        67.95305676,  68.30495761,  68.65685846,  69.0087593 ,
        69.36066015,  69.712561  ,  70.06446185,  70.4163627 ,
        70.76826354,  71.12016439,  71.47206524,  71.82396609,
        72.17586693,  72.52776778,  72.87966863,  73.23156948,
        73.58347033,  73.93537117,  74.28727202,  74.63917287,
        74.99107372,  75.34297457,  75.69487541,  76.04677626,
        76.39867711,  76.75057796,  77.1024788 ,  77.45437965,
        77.8062805 ,  78.15818135,  78.5100822 ,  78.86198304,
        79.21388389,  79.56578474,  79.91768559,  80.26958643,
        80.62148728,  80.97338813,  81.32528898,  81.67718983,
        82.02909067,  82.38099152,  82.73289237,  83.08479322,
        83.43669407,  83.78859491,  84.14049576,  84.49239661,
        84.84429746,  85.1961983 ,  85.54809915,  85.9       ];

// linear scaleLinear
/*
let qs = [ 3959.00542537,  3909.41652661,  3859.82762786,  3810.2387291 ,
       3760.64983034,  3711.06093159,  3661.47203283,  3611.88313407,
       3562.29423531,  3512.70533656,  3463.1164378 ,  3413.52753904,
       3363.93864029,  3314.34974153,  3264.76084277,  3215.17194401,
       3165.58304526,  3115.9941465 ,  3066.40524774,  3016.81634899,
       2967.22745023,  2917.63855147,  2868.04965271,  2818.46075396,
       2768.8718552 ,  2719.28295644,  2669.69405769,  2620.10515893,
       2570.51626017,  2520.92736141,  2471.33846266,  2421.7495639 ,
       2372.16066514,  2322.57176639,  2272.98286763,  2223.39396887,
       2173.80507011,  2124.21617136,  2074.6272726 ,  2025.03837384,
       1975.44947509,  1925.86057633,  1876.27167757,  1826.68277881,
       1777.09388006,  1727.5049813 ,  1677.91608254,  1628.32718379,
       1578.73828503,  1529.14938627,  1479.56048751,  1429.97158876,
       1380.38269   ,  1330.79379124,  1281.20489249,  1231.61599373,
       1182.02709497,  1132.43819621,  1082.84929746,  1033.2603987 ,
        983.67149994,   934.08260119,   884.49370243,   834.90480367,
        785.31590491,   735.72700616,   686.1381074 ,   636.54920864,
        586.96030989,   537.37141113,   487.78251237,   438.19361361,
        388.60471486,   339.0158161 ,   289.42691734,   239.83801859,
        190.24911983,   140.66022107,    91.07132231,    41.48242356,
         -8.1064752 ,   -57.69537396,  -107.28427271,  -156.87317147,
       -206.46207023,  -256.05096899,  -305.63986774,  -355.2287665 ,
       -404.81766526,  -454.40656401,  -503.99546277,  -553.58436153,
       -603.17326029,  -652.76215904,  -702.3510578 ,  -751.93995656,
       -801.52885531,  -851.11775407,  -900.70665283,  -950.29555159];*/

// log scale

let qs = [ 1884.22687466,  1821.41613126,  1760.69918535,  1702.00624013,
       1645.26982551,  1590.42472049,  1537.40787822,  1486.15835353,
       1436.61723285,  1388.7275665 ,  1342.4343032 ,  1297.68422682,
       1254.42589521,  1212.60958101,  1172.18721455,  1133.11232854,
       1095.34000469,  1058.82682208,  1023.53080719,   989.41138572,
        956.42933589,   924.54674341,   893.72695783,   863.93455047,
        835.13527365,   807.29602134,   780.3847911 ,   754.3706473 ,
        729.22368555,   704.91499831,   681.41664168,   658.70160327,
        636.74377116,   615.51790385,   594.99960128,   575.16527678,
        555.99212991,   537.4581203 ,   519.5419423 ,   502.22300047,
        485.48138595,   469.29785351,   453.65379947,   438.5312403 ,
        423.91279198,   409.78164994,   396.12156982,   382.91684877,
        370.15230738,   357.81327225,   345.88555913,   334.35545657,
        323.20971024,   312.4355076 ,   302.02046323,   291.95260459,
        282.22035824,   272.81253653,   263.71832475,   254.92726872,
        246.42926274,   238.21453796,   230.27365122,   222.5974741 ,
        215.17718251,   208.00424651,   201.07042048,   194.36773368,
        187.8884811 ,   181.62521454,   175.57073411,   169.71807991,
        164.06052407,   158.59156297,   153.30490981,   148.19448734,
        143.25442092,   138.47903171,   133.86283021,   129.40050989,
        125.08694111,   120.91716524,   116.88638893,   112.98997864,
        109.22345527,   105.58248904,   102.0628945 ,    98.66062572,
         95.37177164,    92.19255158,    89.11931089,    86.14851674,
         83.27675408,    80.5007217 ,    77.81722841,    75.22318942,
         72.71562279,    70.29164594,    67.94847241,    65.68340862];


function findMin(arr) {
  let i = 0;
  let currMin = arr[i];
  for (i=0;i<arr.length;i++)
    if ( arr[i] < currMin )
      currMin = arr[i];
  return currMin;
}

let minX = findMin(qs);
let minY = findMin(ps);

function generatePointsFromPQ(ps, qs) {
  let len = ps.length;
  let i = 0;
  let ret = [];
  for (i=0; i<len; i++) {
    ret.push( [ qs[i], ps[i] ] );
  }
  return ret;
}

/*let points = [
	[0,100],
	[1,200],
	[2,500],
	[3,300]
	,[4,600]
	,[5,200]
];*/

let points = generatePointsFromPQ(ps, qs);

// Movable points
// let point = [2.5, 400];
//let point2 = [2, 500];
//let point3 = [3, 300];


let num = ps.length;
let point = [ qs[num/2] , ps[num/2] ];
let point2 = [ qs[num/4], ps[num/4] ];
let point3 = [ qs[num/4*3], ps[num/4*3] ];


function mapToY(points, xx) {

  var yy = -1;
	for (var i=1; i<points.length; i++) {
		if ( points[i][0] > xx ) {

			var x0 = points[i-1][0];
			var y0 = points[i-1][1];
			var x1 = points[i][0];
			var y1 = points[i][1];

			yy = y0 + (xx-x0)*(y1-y0)/(x1-x0);

			//var rangeY = point[i][1] - point[i-1][1];
			//var rangeX = point[i][0] - point[i-1][0];
			//var dx1 = inputX - point[i-1][0];
			//var dx2 = point[i][0] - inputX;

			console.log(" i: " + i + " x: " + xx + " y: " +  yy);
			break;

		}
	}
	return yy;
}

function mapToY_v2(points, xx) {

  var yy = points[0][1];
	for (var i=1; i<points.length; i++) {
		if ( points[i][0] < xx ) {

      var x0 = points[i-1][0];
			var y0 = points[i-1][1];
			var x1 = points[i][0];
			var y1 = points[i][1];

			yy = y0 + (xx-x0)*(y1-y0)/(x1-x0);

			//var rangeY = point[i][1] - point[i-1][1];
			//var rangeX = point[i][0] - point[i-1][0];
			//var dx1 = inputX - point[i-1][0];
			//var dx2 = point[i][0] - inputX;

			console.log(" i: " + i + " x: " + xx + " y: " +  yy);
			break;

		}
	}
	return yy;
}


var x = d3.scaleLinear()
    .rangeRound([0, width]);

var y = d3.scaleLinear()
    .rangeRound([height, 0]);

var xAxis = d3.axisBottom(x),
    yAxis = d3.axisLeft(y);

var line = d3.line()
    .x(function(d) { return x(d[0]); })
    .y(function(d) { return y(d[1]); });

let drag = d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended);

svg.append('rect')
    .attr('class', 'zoom')
    .attr('cursor', 'move')
    .attr('fill', 'none')
    .attr('pointer-events', 'all')
    .attr('width', width)
    .attr('height', height)
    .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

 var focus = svg.append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

x.domain(d3.extent(points, function(d) { return d[0]; }));
y.domain(d3.extent(points, function(d) { return d[1]; }));

focus.append("path")
    .datum(points)
    .attr("fill", "none")
    .attr("stroke", "steelblue")
    .attr("stroke-linejoin", "round")
    .attr("stroke-linecap", "round")
    .attr("stroke-width", 1.5)
    .attr("d", line);

/*focus.append("path")
	.datum([points[0], points[3]])
	.attr("fill", "none")
	.attr("stroke", "steelblue")
	.attr("stroke-linejoin", "round")
	.attr("stroke-linecap", "round")
	.attr("stroke-width", 1.5)
	.attr("d", line);*/

  // Point 1: control line 1
	focus.append("path")
			.datum( [  [minX, point[1]], point ] )
			.attr("id","controlLineY")
			.attr("fill", "none")
			.attr("stroke", "red")
			.attr("stroke-linejoin", "round")
			.attr("stroke-linecap", "round")
			.attr("stroke-width", 1.5)
			.attr("stroke-dasharray", "5,5")
			.attr("d", line);


// text labels
    $("#labelPCurrent").text("P: " + parseFloat(point[1]).toFixed(2) + "");
    $("#labelQCurrent").text("Q: " + parseFloat(point[0]).toFixed(2) + "");


    $("#labelPOptimal").text("P: " + parseFloat(point2[1]).toFixed(2) + "");
    $("#labelQOptimal").text("Q: " + parseFloat(point2[0]).toFixed(2) + "");

    $("#labelPTarget").text("P: " + parseFloat(point3[1]).toFixed(2) + "");
    $("#labelQTarget").text("Q: " + parseFloat(point3[0]).toFixed(2) + "");



// Point 1: Extended control line 1
      focus.append("path")
    			.datum( [  [minX, point[1]*0.95], [point[0], point[1]*0.95] ] )
    			.attr("id","controlExtendedLineY")
    			.attr("fill", "none")
    			.attr("stroke", "red")
    			.attr("stroke-linejoin", "round")
    			.attr("stroke-linecap", "round")
    			.attr("stroke-width", 1.5)
    			.attr("stroke-dasharray", "5,5")
    			.attr("d", line);



  // Point 1: control line 2
	focus.append("path")
					.datum( [  [point[0], minY] , point ] )
					.attr("id","controlLineX")
					.attr("fill", "none")
					.attr("stroke", "red")
					.attr("stroke-linejoin", "round")
					.attr("stroke-linecap", "round")
					.attr("stroke-width", 1.5)
					.attr("stroke-dasharray", "5,5")
					.attr("d", line);





  // Point 2: control line 1
  focus.append("path")
        	.datum( [  [minX, point2[1]], point2 ] )
        	.attr("id","control2LineY")
        	.attr("fill", "none")
        	.attr("stroke", "green")
        	.attr("stroke-linejoin", "round")
        	.attr("stroke-linecap", "round")
        	.attr("stroke-width", 1.5)
        	.attr("stroke-dasharray", "5,15")
        	.attr("d", line);

   // Point 2: control line 2
  focus.append("path")
        					.datum( [  [point2[0], minY] , point2 ] )
        					.attr("id","control2LineX")
        					.attr("fill", "none")
        					.attr("stroke", "green")
        					.attr("stroke-linejoin", "round")
        					.attr("stroke-linecap", "round")
        					.attr("stroke-width", 1.5)
        					.attr("stroke-dasharray", "5,15")
        					.attr("d", line);

  // Point 2: control line 1
  focus.append("path")
          .datum( [  [minX, point3[1]], point3 ] )
          .attr("id","control3LineY")
          .attr("fill", "none")
                        	.attr("stroke", "purple")
                        	.attr("stroke-linejoin", "round")
                        	.attr("stroke-linecap", "round")
                        	.attr("stroke-width", 1.5)
                        	.attr("stroke-dasharray", "5,15")
                        	.attr("d", line);

  // Point 2: control line 2
                  focus.append("path")
                        					.datum( [  [point3[0], minY] , point3 ] )
                        					.attr("id","control3LineX")
                        					.attr("fill", "none")
                        					.attr("stroke", "purple")
                        					.attr("stroke-linejoin", "round")
                        					.attr("stroke-linecap", "round")
                        					.attr("stroke-width", 1.5)
                        					.attr("stroke-dasharray", "5,15")
                        					.attr("d", line);







// Movable circles
focus.selectAll('circle')
    .data([point, point2, point3])
    .enter()
    .append('circle')
    .attr('r', 5.0)
    .attr('cx', function(d) { return x(d[0]);  })
    .attr('cy', function(d) { return y(d[1]); })
    .style('cursor', 'pointer')
    .style('fill', 'steelblue');
focus.selectAll('circle').call(drag);







focus.append('g')
    .attr('class', 'axis axis--x')
    .attr('transform', 'translate(0,' + height + ')')
    .call(xAxis);

focus.append('g')
    .attr('class', 'axis axis--y')
    .call(yAxis);

function dragstarted(d) {
    d3.select(this).raise().classed('active', true);
}

function dragged(d) {
    d[0] = x.invert(d3.event.x);
  	//d[1] = y.invert(d3.event.y);
		d[1] = mapToY_v2(points, d[0]);


    d3.select(this)
        .attr('cx', x(d[0]))
        .attr('cy', y(d[1]))
    focus.select('path').attr('d', line);


    // update labels
    $("#labelPCurrent").text("P: " + parseFloat(d[1]).toFixed(2) + "");
    $("#labelQCurrent").text("Q: " + parseFloat(d[0]).toFixed(2) + "");


		focus.select('path#controlLineY').remove();
		focus.append("path")
				.datum( [  [minX, point[1]], point ] )
				.attr("id","controlLineY")
				.attr("fill", "none")
				.attr("stroke", "red")
				.attr("stroke-linejoin", "round")
				.attr("stroke-linecap", "round")
				.attr("stroke-width", 1.5)
				.attr("stroke-dasharray", "5,5")
				.attr("d", line);

focus.select('path#controlLineX').remove();
				focus.append("path")
								.datum( [  [point[0], minY] , point ] )
								.attr("id","controlLineX")
								.attr("fill", "none")
								.attr("stroke", "red")
								.attr("stroke-linejoin", "round")
								.attr("stroke-linecap", "round")
								.attr("stroke-width", 1.5)
								.attr("stroke-dasharray", "5,5")
								.attr("d", line);


                // Point 1: Extended control line 1
                focus.select('path#controlExtendedLineY').remove();
                      focus.append("path")
                    			.datum( [  [minX, point[1]*0.95], [point[0], point[1]*0.95] ] )
                    			.attr("id","controlExtendedLineY")
                    			.attr("fill", "none")
                    			.attr("stroke", "red")
                    			.attr("stroke-linejoin", "round")
                    			.attr("stroke-linecap", "round")
                    			.attr("stroke-width", 1.5)
                    			.attr("stroke-dasharray", "5,5")
                    			.attr("d", line);


}

function dragended(d) {
    d3.select(this).classed('active', false);
}

</script>
